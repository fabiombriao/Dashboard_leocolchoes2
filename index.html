<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Leads - Supabase</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/dist/umd/supabase.min.js"></script>

    <style>
        :root {
            --primary-color: #14b8a6; /* teal-500 */
            --primary-color-hover: #0d9488; /* teal-600 */
            --secondary-color: #64748b; /* slate-500 */
            --secondary-color-hover: #475569; /* slate-600 */
            --background-color: #f8f7f4; /* cream */
            --card-background-color: #ffffff;
            --text-color: #334155; /* slate-700 */
            --text-light-color: #64748b; /* slate-500 */
            --border-color: #e2e8f0; /* slate-200 */
            --success-color: #22c55e; /* green-500 */
            --error-color: #ef4444; /* red-500 */

            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 20px;
            --spacing-xl: 24px;
            --spacing-2xl: 32px;

            --border-radius-base: 8px;
            --border-radius-large: 12px;
            --shadow-base: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #1a1a1a; /* charcoal */
                --card-background-color: #2a2a2a;
                --text-color: #e2e8f0; /* slate-200 */
                --text-light-color: #94a3b8; /* slate-400 */
                --border-color: #475569; /* slate-600 */
            }
        }
        
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: var(--spacing-2xl);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: var(--spacing-2xl);
        }

        h1 {
            font-size: 30px;
            font-weight: 600;
            color: var(--primary-color);
        }

        header p {
            font-size: 16px;
            color: var(--text-light-color);
            margin-top: var(--spacing-xs);
        }

        #config-section, #admin-management-section {
            background-color: var(--card-background-color);
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-large);
            box-shadow: var(--shadow-base);
            margin-bottom: var(--spacing-2xl);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .form-group { margin-bottom: var(--spacing-md); }
        .form-group label { display: block; font-weight: 500; margin-bottom: var(--spacing-xs); font-size: 14px; }
        .form-group input { width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border-color); border-radius: var(--border-radius-base); background-color: var(--background-color); color: var(--text-color); font-size: 16px; }
        .form-group input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(20, 184, 166, 0.2); }

        fieldset { border: 1px solid var(--border-color); padding: var(--spacing-md); border-radius: var(--border-radius-base); margin-top: var(--spacing-lg); }
        legend { padding: 0 var(--spacing-xs); font-weight: 500; font-size: 14px; color: var(--text-light-color); }

        .button-group { display: flex; gap: var(--spacing-md); margin-top: var(--spacing-md); }

        button { width: 100%; padding: var(--spacing-sm) var(--spacing-lg); border: none; border-radius: var(--border-radius-base); background-color: var(--primary-color); color: white; font-size: 16px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; }
        button:hover { background-color: var(--primary-color-hover); }
        button:disabled { background-color: var(--text-light-color); cursor: not-allowed; }
        button.secondary { background-color: var(--secondary-color); }
        button.secondary:hover { background-color: var(--secondary-color-hover); }

        #status-message { margin-top: var(--spacing-md); text-align: center; font-weight: 500; }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--error-color); }

        #dashboard-grid { display: grid; gap: var(--spacing-xl); grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
        .metric-card { background-color: var(--card-background-color); padding: var(--spacing-xl); border-radius: var(--border-radius-large); box-shadow: var(--shadow-base); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .metric-card:hover { transform: translateY(-5px); box-shadow: var(--shadow-hover); }
        .metric-card h2 { font-size: 14px; font-weight: 500; color: var(--text-light-color); display: flex; justify-content: space-between; align-items: center; }
        .metric-card-subtitle { font-size: 12px; font-weight: 400; }
        .metric-card p { font-size: 30px; font-weight: 600; margin-top: var(--spacing-xs); color: var(--primary-color); }

        .hidden { display: none; }
        
        #loader { display: flex; justify-content: center; align-items: center; padding: var(--spacing-2xl); }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: var(--primary-color); animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Client Management Styles */
        #client-list { list-style: none; padding: 0; margin-top: var(--spacing-lg); }
        .client-item { display: flex; justify-content: space-between; align-items: center; padding: var(--spacing-sm); border-bottom: 1px solid var(--border-color); }
        .client-item:last-child { border-bottom: none; }
        .client-item-name { font-weight: 500; }
        .client-item-actions { display: flex; gap: var(--spacing-xs); }
        .client-item-actions button { width: auto; font-size: 12px; padding: var(--spacing-xs) var(--spacing-sm); }
        .client-item-actions .delete-btn { background-color: var(--error-color); }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1 id="main-title">Dashboard de Leads</h1>
            <p>Métricas em tempo real com Supabase</p>
        </header>

        <main>
            <section id="config-section">
                <form id="config-form">
                    <fieldset>
                        <legend>Identificação do Cliente</legend>
                         <div class="form-group">
                            <label for="client-name">Nome do Cliente</label>
                            <input type="text" id="client-name" placeholder="Ex: Agência XYZ" required>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Conexão Supabase</legend>
                        <div class="form-group">
                            <label for="supabase-url">URL do Supabase</label>
                            <input type="url" id="supabase-url" placeholder="https://seu-projeto.supabase.co" value="https://ckmtkcpvqooukdzqrsyt.supabase.co" required>
                        </div>
                        <div class="form-group">
                            <label for="supabase-key">Chave Anônima (anon key)</label>
                            <input type="text" id="supabase-key" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6..." value="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNrbXRrY3B2cW9vdWtkenFyc3l0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE2NTg0MzEsImV4cCI6MjA3NzIzNDQzMX0.GrWYqyYPkjkUMTiWNtEmxLwU6kF6-HCiY382-aM57yE" required>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Configuração Principal de Leads</legend>
                        <div class="form-group">
                            <label for="leads-table-name">Tabela Principal de Leads</label>
                            <input type="text" id="leads-table-name" placeholder="leads" value="leads" required>
                        </div>
                        <div class="form-group">
                            <label for="leads-id-column">Coluna de ID na Tabela de Leads/Eventos</label>
                            <input type="text" id="leads-id-column" placeholder="numero" value="numero" required>
                        </div>
                         <div class="form-group">
                            <label for="qualified-column">Coluna de Qualificado (Booleano: true/false)</label>
                            <input type="text" id="qualified-column" placeholder="atendimento_finalizado" value="atendimento_finalizado">
                        </div>
                         <div class="form-group">
                            <label for="followup-column">Coluna de Follow-up (Booleano/Timestamp)</label>
                            <input type="text" id="followup-column" placeholder="followup" value="followup">
                        </div>
                        <div class="form-group">
                            <label for="last-inbound-column">Coluna de Última Mensagem Recebida (Timestamp)</label>
                            <input type="text" id="last-inbound-column" placeholder="last_inbound_at" value="last_inbound_at">
                        </div>
                        <div class="form-group">
                            <label for="last-outbound-column">Coluna de Última Mensagem Enviada (Timestamp)</label>
                            <input type="text" id="last-outbound-column" placeholder="last_outbound_at" value="last_outbound_at">
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Análise de Chats (Segunda Mensagem e Agendamentos)</legend>
                         <div class="form-group">
                            <label for="chats-table-name">Tabela de Chats (ex: chats_sdr)</label>
                            <input type="text" id="chats-table-name" placeholder="chats_sdr" value="chats_sdr">
                        </div>
                        <div class="form-group">
                            <label for="chats-lead-id-column">Coluna de ID do Lead na Tabela de Chats</label>
                            <input type="text" id="chats-lead-id-column" placeholder="session_id" value="session_id">
                        </div>
                        <div class="form-group">
                            <label for="json-message-column">Coluna com o JSON da Mensagem</label>
                            <input type="text" id="json-message-column" placeholder="message" value="message">
                        </div>
                        <div class="form-group">
                            <label for="json-content-key">Chave do Conteúdo da Mensagem no JSON (ex: content)</label>
                            <input type="text" id="json-content-key" placeholder="content" value="content">
                        </div>
                         <div class="form-group">
                            <label for="json-sender-key">Chave do Remetente no JSON (ex: type)</label>
                            <input type="text" id="json-sender-key" placeholder="role" value="type">
                        </div>
                        <div class="form-group">
                            <label for="human-sender-value">Valor do Remetente Humano (ex: human)</label>
                            <input type="text" id="human-sender-value" placeholder="user" value="human">
                        </div>
                        <div class="form-group">
                            <label for="scheduling-keywords">Palavras-chave de Agendamento (separadas por vírgula)</label>
                            <input type="text" id="scheduling-keywords" placeholder="confirmado, agendado, combinado" value="confirmado, agendado, combinado">
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Análise de Disparos (Opcional)</legend>
                         <div class="form-group">
                            <label for="incoming-shots-table-name">Tabela de Disparos de Entrada (Pendentes)</label>
                            <input type="text" id="incoming-shots-table-name" placeholder="disparo_entrada" value="disparo_entrada">
                        </div>
                        <div class="form-group">
                            <label for="shots-table-name">Tabela de Disparos de Saída (Histórico)</label>
                            <input type="text" id="shots-table-name" placeholder="disparo_saida" value="disparo_saida">
                        </div>
                        <div class="form-group">
                            <label for="shot-attempt-column">Coluna de Tentativa de Disparo (Timestamp não nulo)</label>
                            <input type="text" id="shot-attempt-column" placeholder="created_at" value="created_at">
                        </div>
                        <div class="form-group">
                            <label for="shot-completed-column">Coluna de Disparo Concluído (Booleano)</label>
                            <input type="text" id="shot-completed-column" placeholder="conseguiu" value="conseguiu">
                        </div>
                    </fieldset>

                    <div class="button-group">
                        <button type="submit" id="connect-btn">Conectar e Testar</button>
                        <button type="button" id="save-client-btn" class="secondary">Salvar Configuração do Cliente</button>
                    </div>
                    <p id="status-message"></p>
                </form>
            </section>
            
            <section id="admin-management-section">
                <h2>Gerenciamento de Clientes</h2>
                <ul id="client-list"></ul>
            </section>

            <div id="loader" class="hidden">
                <div class="spinner"></div>
            </div>
            
            <section id="dashboard-grid" class="hidden">
                <div class="metric-card">
                    <h2>Total de Disparos Planejados</h2>
                    <p id="total-planned-shots-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>Disparos Pendentes</h2>
                    <p id="pending-shots-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Disparos com Sucesso</span>
                        <span id="successful-shots-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="successful-shots-value">-</p>
                </div>
                 <div class="metric-card">
                    <h2>
                        <span>Disparos com Falha</span>
                        <span id="failed-shots-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="failed-shots-value">-</p>
                </div>
                 <div class="metric-card">
                    <h2>
                        <span>Leads de Disparos</span>
                        <span id="shots-with-reply-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="shots-with-reply-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Leads Qualificados</span>
                        <span id="qualified-leads-subtitle" class="metric-card-subtitle">(Qualificados / Disparos Concluídos)</span>
                    </h2>
                    <p id="qualified-leads-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>2ª Mensagem Válida</span>
                        <span id="second-message-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="second-message-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Agendamentos</span>
                        <span id="scheduled-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="scheduled-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Leads Recuperados</span>
                         <span id="recovered-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="recovered-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>Total de Leads</h2>
                    <p id="total-leads-value">-</p>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Polyfills para ambientes de sandbox
        if (typeof navigator.locks === 'undefined') {
            navigator.locks = { request: () => Promise.resolve() };
            console.warn("Polyfill: 'navigator.locks' is not defined. Using a mock.");
        }
        try {
            localStorage.setItem('sb_test', 'test');
            localStorage.removeItem('sb_test');
        } catch (e) {
            window.localStorage = {
                getItem: () => null,
                setItem: () => {},
                removeItem: () => {},
                clear: () => {}
            };
            console.warn("Polyfill: 'localStorage' is not available. Using a mock.");
        }


        document.addEventListener('DOMContentLoaded', () => {
            const configForm = document.getElementById('config-form');
            const connectBtn = document.getElementById('connect-btn');
            const saveClientBtn = document.getElementById('save-client-btn');
            const statusMessage = document.getElementById('status-message');
            const loader = document.getElementById('loader');
            const dashboardGrid = document.getElementById('dashboard-grid');
            const configSection = document.getElementById('config-section');
            const adminManagementSection = document.getElementById('admin-management-section');
            const mainTitle = document.getElementById('main-title');
            const clientList = document.getElementById('client-list');
            
            const allInputIds = [
                'client-name', 'supabase-url', 'supabase-key', 'leads-table-name', 
                'leads-id-column', 'qualified-column', 'followup-column', 
                'last-inbound-column', 'last-outbound-column', 'chats-table-name', 
                'chats-lead-id-column', 'json-message-column', 'json-content-key', 
                'json-sender-key', 'human-sender-value', 'scheduling-keywords', 
                'incoming-shots-table-name', 'shots-table-name', 'shot-attempt-column', 'shot-completed-column'
            ];
            const allInputs = allInputIds.reduce((acc, id) => {
                acc[id] = document.getElementById(id);
                return acc;
            }, {});

            // --- Elementos do Dashboard ---
            const totalLeadsEl = document.getElementById('total-leads-value');
            const qualifiedLeadsEl = document.getElementById('qualified-leads-value');
            const qualifiedLeadsSubtitleEl = document.getElementById('qualified-leads-subtitle');
            const secondMessageEl = document.getElementById('second-message-value');
            const secondMessageSubtitleEl = document.getElementById('second-message-subtitle');
            const scheduledEl = document.getElementById('scheduled-value');
            const scheduledSubtitleEl = document.getElementById('scheduled-subtitle');
            const recoveredEl = document.getElementById('recovered-value');
            const recoveredSubtitleEl = document.getElementById('recovered-subtitle');
            const shotsWithReplyEl = document.getElementById('shots-with-reply-value');
            const shotsWithReplySubtitleEl = document.getElementById('shots-with-reply-subtitle');
            // Novos elementos de Disparos
            const totalPlannedShotsEl = document.getElementById('total-planned-shots-value');
            const pendingShotsEl = document.getElementById('pending-shots-value');
            const successfulShotsEl = document.getElementById('successful-shots-value');
            const successfulShotsSubtitleEl = document.getElementById('successful-shots-subtitle');
            const failedShotsEl = document.getElementById('failed-shots-value');
            const failedShotsSubtitleEl = document.getElementById('failed-shots-subtitle');

            let supabaseClient = null;
            let realtimeChannels = [];
            const CLIENT_CONFIGS_KEY = 'supabase_dashboard_configs';

            function initApp() {
                const hash = window.location.hash;
                if (hash && hash.startsWith('#config=')) {
                    handleClientMode(hash.substring(8)); // remove #config=
                } else {
                    handleAdminMode();
                }
            }
            
            function handleClientMode(encodedConfig) {
                console.log("Client mode detected.");
                configSection.classList.add('hidden');
                adminManagementSection.classList.add('hidden');

                try {
                    const configJson = atob(encodedConfig);
                    const config = JSON.parse(configJson);
                    
                    if (config.clientName) {
                        mainTitle.textContent = `Dashboard de Leads - ${config.clientName}`;
                    }

                    // Preencher o formulário (oculto) para que a lógica de conexão funcione
                    Object.keys(config).forEach(key => {
                        const camelKey = key.replace(/-([a-z])/g, g => g[1].toUpperCase());
                        const inputId = camelKey.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
                        if(allInputs[inputId]) {
                            allInputs[inputId].value = config[key];
                        }
                    });
                    
                    // Iniciar a conexão automaticamente
                    connectAndLoad(config);

                } catch (error) {
                    console.error("Failed to decode client config:", error);
                    showStatus("Erro: O link de configuração é inválido ou está corrompido.", 'error');
                }
            }
            
            function handleAdminMode() {
                console.log("Admin mode detected.");
                renderClientList();
                configForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const config = getFormConfig();
                    if (!validateConfig(config, true)) return;
                    connectAndLoad(config);
                });

                saveClientBtn.addEventListener('click', () => {
                    const config = getFormConfig();
                    if (!validateConfig(config, false)) return;
                    
                    const configs = getSavedConfigs();
                    
                    // Se já existir, atualiza. Senão, adiciona.
                    const existingIndex = configs.findIndex(c => c.id === config.id);
                    if (existingIndex > -1) {
                        configs[existingIndex] = config;
                    } else {
                        configs.push(config);
                    }
                    
                    saveConfigs(configs);
                    renderClientList();
                    showStatus(`Configuração para "${config.clientName}" salva com sucesso!`, 'success');
                });
            }

            async function connectAndLoad(config) {
                 setConnectingState(true);
                try {
                    console.log('Creating Supabase client with URL:', config.supabaseUrl);
                    supabaseClient = supabase.createClient(config.supabaseUrl, config.supabaseKey, {
                        auth: { persistSession: false, autoRefreshToken: false }
                    });
                    console.log('Supabase client created successfully.');

                    await loadMetrics(config);
                    setupRealTimeSubscription(config);
                    
                    showStatus('Conectado com sucesso! Exibindo métricas.', 'success');
                    dashboardGrid.classList.remove('hidden');

                } catch (error) {
                    console.error('Connection or fetch error:', error);
                    let userFriendlyError = `Erro: ${error.message}`;
                    if (error.message) {
                        if (error.message.toLowerCase().includes('column') && error.message.toLowerCase().includes('does not exist')) {
                            const columnNameMatch = error.message.match(/column "([^"]+)"/);
                            const columnName = columnNameMatch ? columnNameMatch[1] : 'desconhecida';
                            userFriendlyError = `Erro de Configuração: A coluna "${columnName}" não foi encontrada. Verifique se os nomes das colunas estão corretos.`;
                        } else if (error.message.toLowerCase().includes('relation') && error.message.toLowerCase().includes('does not exist')) {
                             userFriendlyError = `Erro de Configuração: A tabela especificada não foi encontrada. Verifique os nomes das tabelas.`;
                        }
                    }
                    showStatus(userFriendlyError, 'error');
                    dashboardGrid.classList.add('hidden');
                } finally {
                    setConnectingState(false);
                }
            }
            
            // --- Funções de Gerenciamento de Clientes (Admin) ---
            
            function getSavedConfigs() {
                try {
                    const configs = localStorage.getItem(CLIENT_CONFIGS_KEY);
                    return configs ? JSON.parse(configs) : [];
                } catch (e) {
                    return [];
                }
            }
            
            function saveConfigs(configs) {
                localStorage.setItem(CLIENT_CONFIGS_KEY, JSON.stringify(configs));
            }
            
            function renderClientList() {
                const configs = getSavedConfigs();
                clientList.innerHTML = '';
                if (configs.length === 0) {
                    clientList.innerHTML = '<p style="text-align: center; color: var(--text-light-color);">Nenhuma configuração de cliente salva.</p>';
                    return;
                }
                
                configs.forEach(config => {
                    const li = document.createElement('li');
                    li.className = 'client-item';
                    li.innerHTML = `
                        <span class="client-item-name">${config.clientName}</span>
                        <div class="client-item-actions">
                            <button class="load-btn" data-id="${config.id}">Carregar</button>
                            <button class="share-btn" data-id="${config.id}">Compartilhar</button>
                            <button class="delete-btn" data-id="${config.id}">Excluir</button>
                        </div>
                    `;
                    clientList.appendChild(li);
                });
                
                // Add event listeners
                clientList.addEventListener('click', (e) => {
                    const target = e.target;
                    const id = target.dataset.id;
                    if (!id) return;
                    
                    if (target.classList.contains('load-btn')) {
                        const config = configs.find(c => c.id === id);
                        if (config) {
                             Object.keys(config).forEach(key => {
                                const inputId = key.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
                                if (allInputs[inputId]) {
                                    allInputs[inputId].value = config[key];
                                }
                            });
                            showStatus(`Configuração de "${config.clientName}" carregada.`, 'success');
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    } else if (target.classList.contains('share-btn')) {
                         const config = configs.find(c => c.id === id);
                         if (config) {
                            const configToShare = { ...config };
                            delete configToShare.id; // Não precisa do ID no link
                            const jsonString = JSON.stringify(configToShare);
                            const encoded = btoa(jsonString);
                            const baseUrl = window.location.href.split('#')[0];
                            const url = `${baseUrl}#config=${encoded}`;
                            navigator.clipboard.writeText(url).then(() => {
                                showStatus(`Link para "${config.clientName}" copiado para a área de transferência!`, 'success');
                            }).catch(() => {
                                showStatus(`Não foi possível copiar o link.`, 'error');
                            });
                         }
                    } else if (target.classList.contains('delete-btn')) {
                        if (confirm(`Tem certeza que deseja excluir a configuração de "${configs.find(c => c.id === id).clientName}"?`)) {
                            const newConfigs = configs.filter(c => c.id !== id);
                            saveConfigs(newConfigs);
                            renderClientList();
                        }
                    }
                });
            }

            /**
             * Normaliza um número de telefone, removendo caracteres não numéricos
             * e o "nono dígito" de celulares brasileiros.
             * @param {string | number} phoneNumber O número a ser normalizado.
             * @returns {string} O número normalizado.
             */
            function normalizePhoneNumber(phoneNumber) {
                if (!phoneNumber) return '';
                // Remove tudo que não for dígito
                let cleaned = String(phoneNumber).replace(/\D/g, '');
                
                // Remove o '9' extra de celulares brasileiros (formato 55XX9XXXXXXXX)
                if (cleaned.startsWith('55') && cleaned.length === 13 && cleaned.charAt(4) === '9') {
                    cleaned = cleaned.substring(0, 4) + cleaned.substring(5);
                }
                
                return cleaned;
            }
            
            // --- Funções Auxiliares de UI ---
            function setConnectingState(isConnecting) {
                connectBtn.disabled = isConnecting;
                connectBtn.textContent = isConnecting ? 'Conectando...' : 'Conectar e Testar';
                if (isConnecting) {
                   statusMessage.textContent = '';
                   loader.classList.remove('hidden');
                   dashboardGrid.classList.add('hidden');
                } else {
                   loader.classList.add('hidden');
                }
            }
            
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = `status-${type}`;
                setTimeout(() => { if (statusMessage.textContent === message) statusMessage.textContent = ''; }, 5000);
            }

            // --- Funções de Dados ---
            function getFormConfig() {
                const config = {};
                allInputIds.forEach(id => {
                    const camelCaseId = id.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                    config[camelCaseId] = allInputs[id].value.trim();
                });
                config.id = config.clientName.toLowerCase().replace(/\s+/g, '-') + '-' + config.supabaseUrl.split('.')[0].replace('https://', '');
                return config;
            }

            function validateConfig(config, isTest) {
                if (!config.clientName && !isTest) {
                    showStatus('O Nome do Cliente é obrigatório para salvar.', 'error');
                    return false;
                }
                if (!config.supabaseUrl || !config.supabaseKey || !config.leadsTableName || !config.leadsIdColumn) {
                    showStatus('URL, Chave, Tabela de Leads e Coluna de ID de Leads são obrigatórios.', 'error');
                    return false;
                }
                 if (!config.supabaseUrl.includes('supabase.co')) {
                    showStatus('A URL do Supabase parece inválida.', 'error');
                    return false;
                }
                // ... (outras validações)
                return true;
            }
           
            async function loadMetrics(config) {
                console.log(`Fetching metrics from table: "${config.leadsTableName}"`);
                if (!supabaseClient) throw new Error('Supabase client not initialized.');
                const {
                    leadsTableName, leadsIdColumn, qualifiedColumn, followupColumn,
                    chatsTableName, chatsLeadIdColumn, jsonMessageColumn, jsonContentKey, jsonSenderKey, humanSenderValue, schedulingKeywords,
                    incomingShotsTableName, shotsTableName, shotAttemptColumn, shotCompletedColumn
                } = config;

                // 1. Fetch main leads data.
                const { data: leadsData, error: leadsError, count: totalLeads } = await supabaseClient
                    .from(leadsTableName)
                    .select('*', { count: 'exact' })
                    .not(leadsIdColumn, 'is', null)

                if (leadsError) {
                    console.error('Error fetching leads data:', leadsError);
                    throw new Error(`Erro ao buscar dados de leads: ${leadsError.message}`);
                }
                
                if (!leadsData) {
                    // Handle no leads data gracefully
                    console.warn("No leads data found. Some metrics will be zero.");
                }
                
                const validLeadIds = new Set(leadsData.map(l => normalizePhoneNumber(l[leadsIdColumn])).filter(Boolean));

                // 2. Define data fetching promises to run in parallel.
                const fetchAllChatMessages = async () => {
                    const requiredFields = [chatsTableName, chatsLeadIdColumn, jsonMessageColumn, jsonContentKey, jsonSenderKey, humanSenderValue];
                    if (requiredFields.some(f => !f)) return [];
                    let query = supabaseClient.from(chatsTableName).select(`${chatsLeadIdColumn}, ${jsonMessageColumn}`).eq(`${jsonMessageColumn}->>${jsonSenderKey}`, humanSenderValue);
                    const patternsToExclude = [`%pesquisa rápida com meus clientes%`, `%tu pode responder rapidinho?%`, `%você pode responder rapidinho?%`];
                    patternsToExclude.forEach(pattern => {
                        query = query.not(`${jsonMessageColumn}->>${jsonContentKey}`, 'ilike', pattern);
                    });
                    const { data: messages, error } = await query;
                    if (error) throw new Error(`Erro ao buscar dados de chats: ${error.message}`);
                    return messages || [];
                };
            
                const fetchScheduledData = async () => {
                    if (!schedulingKeywords || !chatsTableName || !jsonMessageColumn || !jsonContentKey || !chatsLeadIdColumn) return { data: [], error: null };
                    const keywords = schedulingKeywords.split(',').map(k => k.trim()).filter(k => k);
                    if (keywords.length === 0) return { data: [], error: null };
                    const orFilter = keywords.map(keyword => `${jsonMessageColumn}->>${jsonContentKey}.ilike.%${keyword}%`).join(',');
                    return supabaseClient.from(chatsTableName).select(chatsLeadIdColumn).or(orFilter);
                };

                const fetchOutgoingShotsData = async () => {
                    const emptyResult = { attempts: 0, completed: 0, failed: 0, successfulLeads: [] };
                    if (!shotsTableName || !shotAttemptColumn || !shotCompletedColumn) return emptyResult;

                    const { count: attempts, error: attemptsError } = await supabaseClient.from(shotsTableName).select('*', { count: 'exact', head: true }).not(shotAttemptColumn, 'is', null);
                    if (attemptsError) throw new Error(`Erro ao contar tentativas de disparo: ${attemptsError.message}`);

                    const { data: completedData, count: completed, error: completedError } = await supabaseClient.from(shotsTableName).select(leadsIdColumn, { count: 'exact' }).not(shotAttemptColumn, 'is', null).eq(shotCompletedColumn, true);
                    if (completedError) throw new Error(`Erro ao buscar disparos concluídos: ${completedError.message}`);

                    const { count: failed, error: failedError } = await supabaseClient.from(shotsTableName).select('*', { count: 'exact', head: true }).not(shotAttemptColumn, 'is', null).eq(shotCompletedColumn, false);
                    if (failedError) throw new Error(`Erro ao contar disparos com falha: ${failedError.message}`);
                    
                    const successfulLeads = completedData ? completedData.map(item => normalizePhoneNumber(item[leadsIdColumn])) : [];
                    
                    return { attempts: attempts || 0, completed: completed || 0, failed: failed || 0, successfulLeads };
                };
                
                const fetchIncomingShotsCount = async () => {
                    if (!incomingShotsTableName) return 0;
                    const { count, error } = await supabaseClient.from(incomingShotsTableName).select('*', { count: 'exact', head: true });
                    if (error) throw new Error(`Erro ao contar disparos pendentes: ${error.message}`);
                    return count || 0;
                };
            
                const [ allMessages, { data: scheduledData, error: scheduledError }, outgoingShots, pendingShots ] = await Promise.all([
                    fetchAllChatMessages(), fetchScheduledData(), fetchOutgoingShotsData(), fetchIncomingShotsCount()
                ]);
            
                if (scheduledError) throw new Error(`Erro ao buscar agendamentos: ${scheduledError.message}`);
                
                const totalPlannedShots = (outgoingShots.attempts || 0) + (pendingShots || 0);

                const successfulShotLeadIdsSet = new Set(outgoingShots.successfulLeads.filter(Boolean));
                const qualifiedLeadIdsSet = new Set(
                    leadsData
                        .filter(lead => qualifiedColumn && lead[qualifiedColumn] === true)
                        .map(lead => normalizePhoneNumber(lead[leadsIdColumn]))
                        .filter(Boolean)
                );

                const qualifiedFromShotsNumerator = [...successfulShotLeadIdsSet].filter(id => qualifiedLeadIdsSet.has(id)).length;
                const qualifiedFromShotsDenominator = outgoingShots.completed;

                const leadsFromShotsIds = new Set([...successfulShotLeadIdsSet].filter(id => validLeadIds.has(id)));
                const shotsWithReplyNumerator = leadsFromShotsIds.size;
                const shotsWithReplyDenominator = successfulShotLeadIdsSet.size;
                
                const messageCountsByLead = allMessages.reduce((acc, msg) => {
                    const leadId = normalizePhoneNumber(msg[chatsLeadIdColumn]);
                    if (leadId) acc[leadId] = (acc[leadId] || 0) + 1;
                    return acc;
                }, {});
                const secondMessageNumerator = [...leadsFromShotsIds].filter(id => (messageCountsByLead[id] || 0) >= 2).length;
                const secondMessageDenominator = shotsWithReplyNumerator;
                
                const scheduledLeads = new Set(scheduledData ? scheduledData.map(item => normalizePhoneNumber(item[chatsLeadIdColumn])) : []);
                const scheduledCount = scheduledLeads.size;
                
                const recoveredCount = followupColumn && qualifiedColumn
                    ? leadsData.filter(lead => lead[followupColumn] && lead[qualifiedColumn] === true).length
                    : 0;
                
                updateUI({
                    total: totalLeads || 0,
                    totalPlanned: totalPlannedShots,
                    pending: pendingShots,
                    qualified: { numerator: qualifiedFromShotsNumerator, denominator: qualifiedFromShotsDenominator },
                    secondMessageData: { numerator: secondMessageNumerator, denominator: secondMessageDenominator },
                    scheduled: { numerator: scheduledCount, denominator: shotsWithReplyNumerator },
                    recovered: { numerator: recoveredCount, denominator: shotsWithReplyNumerator },
                    shotsData: { 
                        attempts: outgoingShots.attempts, 
                        completed: outgoingShots.completed,
                        failed: outgoingShots.failed
                    },
                    shotsWithReplyData: { numerator: shotsWithReplyNumerator, denominator: shotsWithReplyDenominator }
                });
            }

            function updateUI(metrics) {
                totalLeadsEl.textContent = metrics.total;
                totalPlannedShotsEl.textContent = metrics.totalPlanned;
                pendingShotsEl.textContent = metrics.pending;
                
                const updateCard = (el, subEl, { numerator, denominator }) => {
                    const percent = denominator > 0 ? (numerator / denominator) * 100 : 0;
                    el.textContent = `${percent.toFixed(1)}%`;
                    subEl.textContent = `(${numerator} de ${denominator})`;
                };
                
                updateCard(qualifiedLeadsEl, qualifiedLeadsSubtitleEl, metrics.qualified);
                updateCard(secondMessageEl, secondMessageSubtitleEl, metrics.secondMessageData);
                updateCard(scheduledEl, scheduledSubtitleEl, metrics.scheduled);
                updateCard(recoveredEl, recoveredSubtitleEl, metrics.recovered);
                updateCard(successfulShotsEl, successfulShotsSubtitleEl, { numerator: metrics.shotsData.completed, denominator: metrics.shotsData.attempts });
                updateCard(failedShotsEl, failedShotsSubtitleEl, { numerator: metrics.shotsData.failed, denominator: metrics.shotsData.attempts });
                updateCard(shotsWithReplyEl, shotsWithReplySubtitleEl, metrics.shotsWithReplyData);
            }

            function setupRealTimeSubscription(config) {
                 if (realtimeChannels.length > 0) {
                    realtimeChannels.forEach(channel => channel.unsubscribe());
                    realtimeChannels = [];
                }
                
                const tablesToSubscribe = [config.leadsTableName, config.chatsTableName, config.shotsTableName, config.incomingShotsTableName].filter(Boolean);
                const uniqueTables = [...new Set(tablesToSubscribe)];

                uniqueTables.forEach(tableName => {
                    console.log(`Subscribing to changes on table: "${tableName}"`);
                    const channel = supabaseClient
                        .channel(`public:${tableName}`)
                        .on('postgres_changes', { event: '*', schema: 'public', table: tableName }, (payload) => {
                            console.log(`Real-time change detected on ${tableName}:`, payload);
                            let currentConfig = getFormConfig();
                             const hash = window.location.hash;
                             if (hash && hash.startsWith('#config=')) {
                                try { currentConfig = JSON.parse(atob(hash.substring(8))); } catch (e) {}
                             }
                            if (validateConfig(currentConfig, true)) {
                                loadMetrics(currentConfig);
                            }
                        })
                        .subscribe((status, err) => {
                            if (status === 'SUBSCRIBED') console.log(`Successfully subscribed to real-time updates for ${tableName}!`);
                            if (status === 'CHANNEL_ERROR') console.error(`Real-time subscription error for ${tableName}:`, err);
                        });
                    realtimeChannels.push(channel);
                });
            }

            initApp();
        });
    </script>
</body>
</html>