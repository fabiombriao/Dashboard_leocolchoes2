<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Leads - Supabase</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/dist/umd/supabase.min.js"></script>

    <style>
        :root {
            --primary-color: #14b8a6; /* teal-500 */
            --primary-color-hover: #0d9488; /* teal-600 */
            --secondary-color: #64748b; /* slate-500 */
            --secondary-color-hover: #475569; /* slate-600 */
            --background-color: #f8f7f4; /* cream */
            --card-background-color: #ffffff;
            --text-color: #334155; /* slate-700 */
            --text-light-color: #64748b; /* slate-500 */
            --border-color: #e2e8f0; /* slate-200 */
            --success-color: #22c55e; /* green-500 */
            --error-color: #ef4444; /* red-500 */

            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 20px;
            --spacing-xl: 24px;
            --spacing-2xl: 32px;

            --border-radius-base: 8px;
            --border-radius-large: 12px;
            --shadow-base: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-hover: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #1a1a1a; /* charcoal */
                --card-background-color: #2a2a2a;
                --text-color: #e2e8f0; /* slate-200 */
                --text-light-color: #94a3b8; /* slate-400 */
                --border-color: #475569; /* slate-600 */
            }
        }
        
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: var(--spacing-2xl);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: var(--spacing-2xl);
        }

        h1 {
            font-size: 30px;
            font-weight: 600;
            color: var(--primary-color);
        }

        header p {
            font-size: 16px;
            color: var(--text-light-color);
            margin-top: var(--spacing-xs);
        }

        #config-section, #admin-management-section {
            background-color: var(--card-background-color);
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-large);
            box-shadow: var(--shadow-base);
            margin-bottom: var(--spacing-2xl);
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .form-group { margin-bottom: var(--spacing-md); }
        .form-group label { display: block; font-weight: 500; margin-bottom: var(--spacing-xs); font-size: 14px; }
        .form-group input { width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border-color); border-radius: var(--border-radius-base); background-color: var(--background-color); color: var(--text-color); font-size: 16px; }
        .form-group input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(20, 184, 166, 0.2); }

        fieldset { border: 1px solid var(--border-color); padding: var(--spacing-md); border-radius: var(--border-radius-base); margin-top: var(--spacing-lg); }
        legend { padding: 0 var(--spacing-xs); font-weight: 500; font-size: 14px; color: var(--text-light-color); }

        .button-group { display: flex; gap: var(--spacing-md); margin-top: var(--spacing-md); }

        button { padding: var(--spacing-sm) var(--spacing-lg); border: none; border-radius: var(--border-radius-base); background-color: var(--primary-color); color: white; font-size: 16px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; }
        .button-group button { width: 100%; }
        button:hover { background-color: var(--primary-color-hover); }
        button:disabled { background-color: var(--text-light-color); cursor: not-allowed; }
        button.secondary { background-color: var(--secondary-color); }
        button.secondary:hover { background-color: var(--secondary-color-hover); }

        #status-message { margin-top: var(--spacing-md); text-align: center; font-weight: 500; }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--error-color); }

        #dashboard-grid { display: grid; gap: var(--spacing-xl); grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
        .metric-card { background-color: var(--card-background-color); padding: var(--spacing-xl); border-radius: var(--border-radius-large); box-shadow: var(--shadow-base); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .metric-card:hover { transform: translateY(-5px); box-shadow: var(--shadow-hover); }
        .metric-card h2 { font-size: 14px; font-weight: 500; color: var(--text-light-color); display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .metric-card-subtitle { font-size: 12px; font-weight: 400; }
        .metric-card p { font-size: 30px; font-weight: 600; margin-top: var(--spacing-xs); color: var(--primary-color); }

        .hidden { display: none; }
        
        #loader { display: flex; justify-content: center; align-items: center; padding: var(--spacing-2xl); }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: var(--primary-color); animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Client Management Styles */
        #client-list { list-style: none; padding: 0; margin-top: var(--spacing-lg); }
        .client-item { display: flex; justify-content: space-between; align-items: center; padding: var(--spacing-sm); border-bottom: 1px solid var(--border-color); }
        .client-item:last-child { border-bottom: none; }
        .client-item-name { font-weight: 500; }
        .client-item-actions { display: flex; gap: var(--spacing-xs); }
        .client-item-actions button { width: auto; font-size: 12px; padding: var(--spacing-xs) var(--spacing-sm); }
        .client-item-actions .delete-btn { background-color: var(--error-color); }

        /* Date Filter Styles */
        #date-filter-section {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-2xl);
            background-color: var(--card-background-color);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-large);
            box-shadow: var(--shadow-base);
        }
        #date-filter-section .date-filter-buttons button {
            background-color: var(--secondary-color);
        }
        #date-filter-section .date-filter-buttons button.active {
            background-color: var(--primary-color);
        }
        #date-filter-section .date-filter-custom {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }
        #date-filter-section .date-filter-custom input[type="date"] {
             padding: 8px;
             border: 1px solid var(--border-color);
             border-radius: var(--border-radius-base);
             background-color: var(--background-color);
             color: var(--text-color);
        }
        #date-filter-section .date-filter-custom button {
            font-size: 14px;
            padding: 9px var(--spacing-sm);
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1 id="main-title">Dashboard de Leads</h1>
            <p>Métricas em tempo real com Supabase</p>
        </header>

        <main>
            <section id="config-section">
                <form id="config-form">
                    <fieldset>
                        <legend>Identificação do Cliente</legend>
                         <div class="form-group">
                            <label for="client-name">Nome do Cliente</label>
                            <input type="text" id="client-name" placeholder="Ex: Agência XYZ" required>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Conexão Supabase</legend>
                        <div class="form-group">
                            <label for="supabase-url">URL do Supabase</label>
                            <input type="url" id="supabase-url" placeholder="https://seu-projeto.supabase.co" value="https://ckmtkcpvqooukdzqrsyt.supabase.co" required>
                        </div>
                        <div class="form-group">
                            <label for="supabase-key">Chave Anônima (anon key)</label>
                            <input type="text" id="supabase-key" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6..." value="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNrbXRrY3B2cW9vdWtkenFyc3l0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE2NTg0MzEsImV4cCI6MjA3NzIzNDQzMX0.GrWYqyYPkjkUMTiWNtEmxLwU6kF6-HCiY382-aM57yE" required>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Configuração Principal de Leads</legend>
                        <div class="form-group">
                            <label for="leads-table-name">Tabela Principal de Leads</label>
                            <input type="text" id="leads-table-name" placeholder="leads" value="leads" required>
                        </div>
                        <div class="form-group">
                            <label for="leads-id-column">Coluna de ID na Tabela de Leads/Eventos</label>
                            <input type="text" id="leads-id-column" placeholder="numero" value="numero" required>
                        </div>
                         <div class="form-group">
                            <label for="qualified-column">Coluna de Qualificado (Booleano: true/false)</label>
                            <input type="text" id="qualified-column" placeholder="atendimento_finalizado" value="atendimento_finalizado">
                        </div>
                         <div class="form-group">
                            <label for="followup-column">Coluna de Follow-up (Booleano/Timestamp)</label>
                            <input type="text" id="followup-column" placeholder="followup" value="followup">
                        </div>
                         <div class="form-group">
                            <label for="leads-created-at-column">Coluna de Criação do Lead (Timestamp)</label>
                            <input type="text" id="leads-created-at-column" placeholder="created_at" value="created_at">
                        </div>
                        <div class="form-group">
                            <label for="last-inbound-column">Coluna de Última Mensagem Recebida (Timestamp)</label>
                            <input type="text" id="last-inbound-column" placeholder="last_inbound_at" value="last_inbound_at">
                        </div>
                        <div class="form-group">
                            <label for="last-outbound-column">Coluna de Última Mensagem Enviada (Timestamp)</label>
                            <input type="text" id="last-outbound-column" placeholder="last_outbound_at" value="last_outbound_at">
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Análise de Chats (Segunda Mensagem e Agendamentos)</legend>
                         <div class="form-group">
                            <label for="chats-table-name">Tabela de Chats (ex: chats_sdr)</label>
                            <input type="text" id="chats-table-name" placeholder="chats_sdr" value="chats_sdr">
                        </div>
                         <div class="form-group">
                            <label for="chats-created-at-column">Coluna de Criação do Chat (Timestamp)</label>
                            <input type="text" id="chats-created-at-column" placeholder="created_at" value="created_at">
                        </div>
                        <div class="form-group">
                            <label for="chats-lead-id-column">Coluna de ID do Lead na Tabela de Chats</label>
                            <input type="text" id="chats-lead-id-column" placeholder="session_id" value="session_id">
                        </div>
                        <div class="form-group">
                            <label for="json-message-column">Coluna com o JSON da Mensagem</label>
                            <input type="text" id="json-message-column" placeholder="message" value="message">
                        </div>
                        <div class="form-group">
                            <label for="json-content-key">Chave do Conteúdo da Mensagem no JSON (ex: content)</label>
                            <input type="text" id="json-content-key" placeholder="content" value="content">
                        </div>
                         <div class="form-group">
                            <label for="json-sender-key">Chave do Remetente no JSON (ex: type)</label>
                            <input type="text" id="json-sender-key" placeholder="role" value="type">
                        </div>
                        <div class="form-group">
                            <label for="human-sender-value">Valor do Remetente Humano (ex: human)</label>
                            <input type="text" id="human-sender-value" placeholder="user" value="human">
                        </div>
                        <div class="form-group">
                            <label for="scheduling-keywords">Palavras-chave de Agendamento (separadas por vírgula)</label>
                            <input type="text" id="scheduling-keywords" placeholder="confirmado, agendado, combinado" value="confirmado, agendado, combinado">
                        </div>
                        <div class="form-group">
                            <label for="off-hours-keyword">Palavra-chave Qualificação Fora do Horário (ex: *Lead qualificado*)</label>
                            <input type="text" id="off-hours-keyword" placeholder="*Lead qualificado*" value="*Lead qualificado*">
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Análise de Disparos (Opcional)</legend>
                         <div class="form-group">
                            <label for="incoming-shots-table-name">Tabela de Disparos de Entrada (Pendentes)</label>
                            <input type="text" id="incoming-shots-table-name" placeholder="disparo_entrada" value="disparo_entrada">
                        </div>
                        <div class="form-group">
                            <label for="shots-table-name">Tabela de Disparos de Saída (Histórico)</label>
                            <input type="text" id="shots-table-name" placeholder="disparo_saida" value="disparo_saida">
                        </div>
                        <div class="form-group">
                            <label for="shot-attempt-column">Coluna de Tentativa de Disparo (Timestamp não nulo)</label>
                            <input type="text" id="shot-attempt-column" placeholder="created_at" value="created_at">
                        </div>
                        <div class="form-group">
                            <label for="shot-completed-column">Coluna de Disparo Concluído (Booleano)</label>
                            <input type="text" id="shot-completed-column" placeholder="conseguiu" value="conseguiu">
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Análise de Performance da IA (Opcional)</legend>
                        <div class="form-group">
                            <label for="n8n-executions-table-name">Tabela de Execuções (ex: n8n_executions)</label>
                            <input type="text" id="n8n-executions-table-name" placeholder="n8n_executions" value="n8n_executions">
                        </div>
                        <div class="form-group">
                            <label for="execution-started-at-column">Coluna de Início da Execução (Timestamp)</label>
                            <input type="text" id="execution-started-at-column" placeholder="started_at" value="started_at">
                        </div>
                        <div class="form-group">
                            <label for="execution-finished-at-column">Coluna de Fim da Execução (Timestamp)</label>
                            <input type="text" id="execution-finished-at-column" placeholder="stopped_at" value="stopped_at">
                        </div>
                    </fieldset>

                    <div class="button-group">
                        <button type="submit" id="connect-btn">Conectar e Testar</button>
                        <button type="button" id="save-client-btn" class="secondary">Salvar Configuração do Cliente</button>
                    </div>
                    <p id="status-message"></p>
                </form>
            </section>
            
            <section id="admin-management-section">
                <h2>Gerenciamento de Clientes</h2>
                <ul id="client-list"></ul>
            </section>

            <div id="loader" class="hidden">
                <div class="spinner"></div>
            </div>

            <section id="date-filter-section" class="hidden">
                <div class="date-filter-buttons">
                    <button data-period="all">Todos</button>
                    <button data-period="today">Hoje</button>
                    <button data-period="week">Esta Semana</button>
                    <button data-period="month">Este Mês</button>
                </div>
                <div class="date-filter-custom">
                    <input type="date" id="start-date" aria-label="Data de início">
                    <span>até</span>
                    <input type="date" id="end-date" aria-label="Data de fim">
                    <button id="apply-custom-date">Aplicar</button>
                </div>
            </section>
            
            <section id="dashboard-grid" class="hidden">
                <div class="metric-card">
                    <h2>Total de Disparos Planejados</h2>
                    <p id="total-planned-shots-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>Disparos Pendentes</h2>
                    <p id="pending-shots-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Disparos com Sucesso</span>
                        <span id="successful-shots-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="successful-shots-value">-</p>
                </div>
                 <div class="metric-card">
                    <h2>
                        <span>Disparos com Falha</span>
                        <span id="failed-shots-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="failed-shots-value">-</p>
                </div>
                 <div class="metric-card">
                    <h2>
                        <span>Leads de Disparos</span>
                        <span id="shots-with-reply-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="shots-with-reply-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Leads Qualificados</span>
                        <span id="qualified-leads-subtitle" class="metric-card-subtitle">(Qualificados / Disparos Concluídos)</span>
                    </h2>
                    <p id="qualified-leads-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>2ª Mensagem Válida</span>
                        <span id="second-message-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="second-message-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Agendamentos</span>
                        <span id="scheduled-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="scheduled-value">-</p>
                </div>
                 <div class="metric-card">
                    <h2>
                        <span>Agendamentos Fora do Horário</span>
                        <span id="off-hours-scheduled-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="off-hours-scheduled-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>Tempo Médio de Resposta (IA)</h2>
                    <p id="avg-response-time-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>
                        <span>Leads Recuperados</span>
                         <span id="recovered-subtitle" class="metric-card-subtitle"></span>
                    </h2>
                    <p id="recovered-value">-</p>
                </div>
                <div class="metric-card">
                    <h2>Total de Leads (Criados)</h2>
                    <p id="total-leads-value">-</p>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Polyfills para ambientes de sandbox
        if (typeof navigator.locks === 'undefined') {
            navigator.locks = { request: () => Promise.resolve() };
            console.warn("Polyfill: 'navigator.locks' is not defined. Using a mock.");
        }
        try {
            localStorage.setItem('sb_test', 'test');
            localStorage.removeItem('sb_test');
        } catch (e) {
            window.localStorage = {
                getItem: () => null,
                setItem: () => {},
                removeItem: () => {},
                clear: () => {}
            };
            console.warn("Polyfill: 'localStorage' is not available. Using a mock.");
        }


        document.addEventListener('DOMContentLoaded', () => {
            const configForm = document.getElementById('config-form');
            const connectBtn = document.getElementById('connect-btn');
            const saveClientBtn = document.getElementById('save-client-btn');
            const statusMessage = document.getElementById('status-message');
            const loader = document.getElementById('loader');
            const dashboardGrid = document.getElementById('dashboard-grid');
            const configSection = document.getElementById('config-section');
            const adminManagementSection = document.getElementById('admin-management-section');
            const mainTitle = document.getElementById('main-title');
            const clientList = document.getElementById('client-list');
            const dateFilterSection = document.getElementById('date-filter-section');
            
            const allInputIds = [
                'client-name', 'supabase-url', 'supabase-key', 'leads-table-name', 
                'leads-id-column', 'qualified-column', 'followup-column', 'leads-created-at-column',
                'last-inbound-column', 'last-outbound-column', 'chats-table-name', 'chats-created-at-column',
                'chats-lead-id-column', 'json-message-column', 'json-content-key', 
                'json-sender-key', 'human-sender-value', 'scheduling-keywords', 'off-hours-keyword',
                'incoming-shots-table-name', 'shots-table-name', 'shot-attempt-column', 'shot-completed-column',
                'n8n-executions-table-name', 'execution-started-at-column', 'execution-finished-at-column'
            ];
            const allInputs = allInputIds.reduce((acc, id) => {
                acc[id] = document.getElementById(id);
                return acc;
            }, {});

            const DEFAULTS = {
                supabaseUrl: 'https://ckmtkcpvqooukdzqrsyt.supabase.co',
                supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNrbXRrY3B2cW9vdWtkenFyc3l0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE2NTg0MzEsImV4cCI6MjA3NzIzNDQzMX0.GrWYqyYPkjkUMTiWNtEmxLwU6kF6-HCiY382-aM57yE',
                leadsTableName: 'leads',
                leadsIdColumn: 'numero',
                qualifiedColumn: 'atendimento_finalizado',
                followupColumn: 'followup',
                leadsCreatedAtColumn: 'created_at',
                lastInboundColumn: 'last_inbound_at',
                lastOutboundColumn: 'last_outbound_at',
                chatsTableName: 'chats_sdr',
                chatsCreatedAtColumn: 'created_at',
                chatsLeadIdColumn: 'session_id',
                jsonMessageColumn: 'message',
                jsonContentKey: 'content',
                jsonSenderKey: 'type',
                humanSenderValue: 'human',
                schedulingKeywords: 'confirmado, agendado, combinado',
                offHoursKeyword: '*Lead qualificado*',
                incomingShotsTableName: 'disparo_entrada',
                shotsTableName: 'disparo_saida',
                shotAttemptColumn: 'created_at',
                shotCompletedColumn: 'conseguiu',
                n8nExecutionsTableName: 'n8n_executions',
                executionStartedAtColumn: 'started_at',
                executionFinishedAtColumn: 'stopped_at',
            };

            // --- Elementos do Dashboard ---
            const totalLeadsEl = document.getElementById('total-leads-value');
            const qualifiedLeadsEl = document.getElementById('qualified-leads-value');
            const qualifiedLeadsSubtitleEl = document.getElementById('qualified-leads-subtitle');
            const secondMessageEl = document.getElementById('second-message-value');
            const secondMessageSubtitleEl = document.getElementById('second-message-subtitle');
            const scheduledEl = document.getElementById('scheduled-value');
            const scheduledSubtitleEl = document.getElementById('scheduled-subtitle');
            const recoveredEl = document.getElementById('recovered-value');
            const recoveredSubtitleEl = document.getElementById('recovered-subtitle');
            const shotsWithReplyEl = document.getElementById('shots-with-reply-value');
            const shotsWithReplySubtitleEl = document.getElementById('shots-with-reply-subtitle');
            const totalPlannedShotsEl = document.getElementById('total-planned-shots-value');
            const pendingShotsEl = document.getElementById('pending-shots-value');
            const successfulShotsEl = document.getElementById('successful-shots-value');
            const successfulShotsSubtitleEl = document.getElementById('successful-shots-subtitle');
            const failedShotsEl = document.getElementById('failed-shots-value');
            const failedShotsSubtitleEl = document.getElementById('failed-shots-subtitle');
            const avgResponseTimeEl = document.getElementById('avg-response-time-value');
            const offHoursScheduledEl = document.getElementById('off-hours-scheduled-value');
            const offHoursScheduledSubtitleEl = document.getElementById('off-hours-scheduled-subtitle');

            let supabaseClient = null;
            let realtimeChannels = [];
            const CLIENT_CONFIGS_KEY = 'supabase_dashboard_configs';
            let maxTotalPlannedShots = 0;
            let dateRange = { start: null, end: null };

            function initApp() {
                setupDateFilterListeners();
                const hash = window.location.hash;
                if (hash && hash.startsWith('#config=')) {
                    handleClientMode(hash.substring(8));
                } else {
                    handleAdminMode();
                }
            }
            
            function handleClientMode(encodedConfig) {
                console.log("Client mode detected.");
                configSection.classList.add('hidden');
                adminManagementSection.classList.add('hidden');

                try {
                    const configJson = atob(encodedConfig);
                    const partialConfig = JSON.parse(configJson);
                    const config = { ...DEFAULTS, ...partialConfig };
                    
                    if (config.clientName) mainTitle.textContent = `Dashboard de Leads - ${config.clientName}`;

                    Object.keys(config).forEach(key => {
                        const inputId = key.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
                        if(allInputs[inputId]) allInputs[inputId].value = config[key];
                    });
                    
                    connectAndLoad(config);

                } catch (error) {
                    console.error("Failed to decode client config:", error);
                    showStatus("Erro: O link de configuração é inválido ou está corrompido.", 'error');
                }
            }
            
            function handleAdminMode() {
                console.log("Admin mode detected.");
                renderClientList();
                configForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const config = getFormConfig();
                    if (!validateConfig(config, true)) return;
                    connectAndLoad(config);
                });

                saveClientBtn.addEventListener('click', () => {
                    const config = getFormConfig();
                    if (!validateConfig(config, false)) return;
                    const configs = getSavedConfigs();
                    const existingIndex = configs.findIndex(c => c.id === config.id);
                    if (existingIndex > -1) configs[existingIndex] = config;
                    else configs.push(config);
                    saveConfigs(configs);
                    renderClientList();
                    showStatus(`Configuração para "${config.clientName}" salva com sucesso!`, 'success');
                });
            }

            async function connectAndLoad(config) {
                 maxTotalPlannedShots = 0;
                 setConnectingState(true);
                try {
                    supabaseClient = supabase.createClient(config.supabaseUrl, config.supabaseKey, {
                        auth: { persistSession: false, autoRefreshToken: false }
                    });
                    
                    // Default to 'all' on first load
                    if (!dateRange.start && !document.querySelector('.date-filter-buttons button.active')) {
                         document.querySelector('#date-filter-section [data-period="all"]').click();
                    } else {
                         await loadMetrics(config, dateRange);
                    }
                    
                    setupRealTimeSubscription(config);
                    
                    showStatus('Conectado com sucesso! Exibindo métricas.', 'success');
                    dashboardGrid.classList.remove('hidden');
                    dateFilterSection.classList.remove('hidden');

                } catch (error) {
                    console.error('Connection or fetch error:', error);
                    let userFriendlyError = `Erro: ${error.message}`;
                    if (error.message) {
                        if (error.message.toLowerCase().includes('column') && error.message.toLowerCase().includes('does not exist')) {
                            const columnNameMatch = error.message.match(/column "([^"]+)"/);
                            const columnName = columnNameMatch ? columnNameMatch[1] : 'desconhecida';
                            userFriendlyError = `Erro de Configuração: A coluna "${columnName}" não foi encontrada. Verifique se os nomes das colunas estão corretos.`;
                        } else if (error.message.toLowerCase().includes('relation') && error.message.toLowerCase().includes('does not exist')) {
                             userFriendlyError = `Erro de Configuração: A tabela especificada não foi encontrada. Verifique os nomes das tabelas.`;
                        }
                    }
                    showStatus(userFriendlyError, 'error');
                    dashboardGrid.classList.add('hidden');
                    dateFilterSection.classList.add('hidden');
                } finally {
                    setConnectingState(false);
                }
            }

            function setupDateFilterListeners() {
                const buttons = dateFilterSection.querySelectorAll('.date-filter-buttons button');
                const startDateInput = document.getElementById('start-date');
                const endDateInput = document.getElementById('end-date');
                
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        buttons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        const period = button.dataset.period;
                        const now = new Date();
                        let start = new Date();
                        let end = new Date();

                        if (period === 'all') {
                            start = null;
                            end = null;
                            startDateInput.value = '';
                            endDateInput.value = '';
                        } else if (period === 'today') {
                            start.setHours(0, 0, 0, 0);
                            end.setHours(23, 59, 59, 999);
                        } else if (period === 'week') {
                            start.setDate(now.getDate() - now.getDay());
                            start.setHours(0, 0, 0, 0);
                        } else if (period === 'month') {
                            start.setDate(1);
                            start.setHours(0, 0, 0, 0);
                        }
                        
                        dateRange = { start, end };
                        if (start) startDateInput.valueAsDate = start;
                        if (end) endDateInput.valueAsDate = end;
                        
                        if (supabaseClient) loadMetrics(getFormConfig(), dateRange);
                    });
                });

                document.getElementById('apply-custom-date').addEventListener('click', () => {
                    buttons.forEach(btn => btn.classList.remove('active'));
                    const start = startDateInput.valueAsDate;
                    const end = endDateInput.valueAsDate;
                    if (start && end) {
                        start.setHours(0, 0, 0, 0);
                        end.setHours(23, 59, 59, 999);
                        dateRange = { start, end };
                        if (supabaseClient) loadMetrics(getFormConfig(), dateRange);
                    }
                });
            }
            
            function getSavedConfigs() {
                try {
                    const configs = localStorage.getItem(CLIENT_CONFIGS_KEY);
                    return configs ? JSON.parse(configs) : [];
                } catch (e) { return []; }
            }
            
            function saveConfigs(configs) {
                localStorage.setItem(CLIENT_CONFIGS_KEY, JSON.stringify(configs));
            }
            
            function renderClientList() {
                const configs = getSavedConfigs();
                clientList.innerHTML = '';
                if (configs.length === 0) {
                    clientList.innerHTML = '<p style="text-align: center; color: var(--text-light-color);">Nenhuma configuração de cliente salva.</p>';
                    return;
                }
                configs.forEach(config => {
                    const li = document.createElement('li');
                    li.className = 'client-item';
                    li.innerHTML = `
                        <span class="client-item-name">${config.clientName}</span>
                        <div class="client-item-actions">
                            <button class="load-btn" data-id="${config.id}">Carregar</button>
                            <button class="share-btn" data-id="${config.id}">Compartilhar</button>
                            <button class="delete-btn" data-id="${config.id}">Excluir</button>
                        </div>
                    `;
                    clientList.appendChild(li);
                });
                clientList.addEventListener('click', (e) => {
                    const target = e.target;
                    const id = target.dataset.id;
                    if (!id) return;
                    const config = configs.find(c => c.id === id);
                    if (!config) return;
                    
                    if (target.classList.contains('load-btn')) {
                         Object.keys(config).forEach(key => {
                            const inputId = key.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
                            if (allInputs[inputId]) allInputs[inputId].value = config[key];
                        });
                        showStatus(`Configuração de "${config.clientName}" carregada.`, 'success');
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    } else if (target.classList.contains('share-btn')) {
                        const shortenedConfig = {};
                        Object.keys(config).forEach(key => {
                            if (key !== 'id' && DEFAULTS[key] !== config[key]) {
                                shortenedConfig[key] = config[key];
                            }
                        });
                        shortenedConfig.clientName = config.clientName; // Always include name
                        const jsonString = JSON.stringify(shortenedConfig);
                        const encoded = btoa(jsonString);
                        const url = `${window.location.href.split('#')[0]}#config=${encoded}`;
                        navigator.clipboard.writeText(url).then(() => {
                            showStatus(`Link para "${config.clientName}" copiado!`, 'success');
                        });
                    } else if (target.classList.contains('delete-btn')) {
                        if (confirm(`Excluir "${config.clientName}"?`)) {
                            saveConfigs(configs.filter(c => c.id !== id));
                            renderClientList();
                        }
                    }
                });
            }

            function normalizePhoneNumber(phoneNumber) {
                if (!phoneNumber) return '';
                let cleaned = String(phoneNumber).replace(/\D/g, '');
                if (cleaned.startsWith('55') && cleaned.length === 13 && cleaned.charAt(4) === '9') {
                    cleaned = cleaned.substring(0, 4) + cleaned.substring(5);
                }
                return cleaned;
            }
            
            function setConnectingState(isConnecting) {
                connectBtn.disabled = isConnecting;
                connectBtn.textContent = isConnecting ? 'Conectando...' : 'Conectar e Testar';
                loader.classList.toggle('hidden', !isConnecting);
                if (isConnecting) {
                   statusMessage.textContent = '';
                   dashboardGrid.classList.add('hidden');
                   dateFilterSection.classList.add('hidden');
                }
            }
            
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = `status-${type}`;
                setTimeout(() => { if (statusMessage.textContent === message) statusMessage.textContent = ''; }, 5000);
            }

            function getFormConfig() {
                const config = {};
                allInputIds.forEach(id => {
                    const camelCaseId = id.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                    config[camelCaseId] = allInputs[id].value.trim();
                });
                config.id = config.clientName.toLowerCase().replace(/\s+/g, '-') + '-' + config.supabaseUrl.split('.')[0].replace('https://', '');
                return config;
            }

            function validateConfig(config, isTest) {
                if (!config.clientName && !isTest) {
                    showStatus('O Nome do Cliente é obrigatório para salvar.', 'error'); return false;
                }
                if (!config.supabaseUrl || !config.supabaseKey || !config.leadsTableName || !config.leadsIdColumn) {
                    showStatus('URL, Chave, Tabela de Leads e Coluna de ID de Leads são obrigatórios.', 'error'); return false;
                }
                 if (!config.supabaseUrl.includes('supabase.co')) {
                    showStatus('A URL do Supabase parece inválida.', 'error'); return false;
                }
                return true;
            }
           
            async function loadMetrics(config, dateRange) {
                console.log(`Fetching metrics from table: "${config.leadsTableName}" for period:`, dateRange.start ? dateRange : 'All time');
                if (!supabaseClient) throw new Error('Supabase client not initialized.');
                const {
                    leadsTableName, leadsIdColumn, qualifiedColumn, followupColumn, leadsCreatedAtColumn,
                    chatsTableName, chatsLeadIdColumn, jsonMessageColumn, jsonContentKey, jsonSenderKey, humanSenderValue, schedulingKeywords, chatsCreatedAtColumn, offHoursKeyword,
                    incomingShotsTableName, shotsTableName, shotAttemptColumn, shotCompletedColumn,
                    n8nExecutionsTableName, executionStartedAtColumn, executionFinishedAtColumn
                } = config;
                
                const addDateFilter = (query, column) => {
                    if (dateRange && dateRange.start && dateRange.end && column) {
                        return query.gte(column, dateRange.start.toISOString()).lte(column, dateRange.end.toISOString());
                    }
                    return query;
                };

                // 1. Fetch TOTAL LEADS Count (Leads CREATED in this period)
                // This is a cohort metric: "How many new leads entered the system?"
                let leadsCountQuery = supabaseClient.from(leadsTableName).select(leadsIdColumn, { count: 'exact', head: true }).not(leadsIdColumn, 'is', null);
                leadsCountQuery = addDateFilter(leadsCountQuery, leadsCreatedAtColumn);
                const { count: totalLeads, error: leadsError } = await leadsCountQuery;
                if (leadsError) throw new Error(`Erro ao buscar contagem de leads: ${leadsError.message}`);

                // 2. Define data fetching promises for ACTIVITY metrics (Shots, Chats, Scheduling)
                const fetchAllChatMessages = async () => {
                    const required = [chatsTableName, chatsLeadIdColumn, jsonMessageColumn, jsonContentKey, jsonSenderKey, humanSenderValue, chatsCreatedAtColumn];
                    if (required.some(f => !f)) return [];
                    let query = supabaseClient.from(chatsTableName).select(`${chatsLeadIdColumn}, ${jsonMessageColumn}`).eq(`${jsonMessageColumn}->>${jsonSenderKey}`, humanSenderValue);
                    const patterns = [`%pesquisa rápida com meus clientes%`, `%tu pode responder rapidinho?%`, `%você pode responder rapidinho?%`];
                    patterns.forEach(p => { query = query.not(`${jsonMessageColumn}->>${jsonContentKey}`, 'ilike', p); });
                    query = addDateFilter(query, chatsCreatedAtColumn);
                    const { data, error } = await query;
                    if (error) throw new Error(`Erro ao buscar dados de chats: ${error.message}`);
                    return data || [];
                };
            
                const fetchScheduledData = async () => {
                    const required = [schedulingKeywords, chatsTableName, jsonMessageColumn, jsonContentKey, chatsLeadIdColumn, chatsCreatedAtColumn];
                    if (required.some(f => !f)) return { data: [] };
                    const keywords = schedulingKeywords.split(',').map(k => k.trim()).filter(k => k);
                    if (keywords.length === 0) return { data: [] };
                    const orFilter = keywords.map(keyword => `${jsonMessageColumn}->>${jsonContentKey}.ilike.%${keyword}%`).join(',');
                    let query = supabaseClient.from(chatsTableName).select(chatsLeadIdColumn).or(orFilter);
                    query = addDateFilter(query, chatsCreatedAtColumn);
                    return query;
                };

                const fetchOutgoingShotsData = async () => {
                    const empty = { attempts: 0, completed: 0, failed: 0, successfulLeads: [] };
                    if (!shotsTableName || !shotAttemptColumn || !shotCompletedColumn) return empty;

                    let attemptsQuery = supabaseClient.from(shotsTableName).select('*', { count: 'exact', head: true }).not(shotAttemptColumn, 'is', null);
                    attemptsQuery = addDateFilter(attemptsQuery, shotAttemptColumn);
                    const { count: attempts, error: errA } = await attemptsQuery;
                    if (errA) throw new Error(`Erro ao contar tentativas de disparo: ${errA.message}`);

                    let completedQuery = supabaseClient.from(shotsTableName).select(leadsIdColumn, { count: 'exact' }).not(shotAttemptColumn, 'is', null).eq(shotCompletedColumn, true);
                    completedQuery = addDateFilter(completedQuery, shotAttemptColumn);
                    const { data: completedData, count: completed, error: errC } = await completedQuery;
                    if (errC) throw new Error(`Erro ao buscar disparos concluídos: ${errC.message}`);

                    let failedQuery = supabaseClient.from(shotsTableName).select('*', { count: 'exact', head: true }).not(shotAttemptColumn, 'is', null).eq(shotCompletedColumn, false);
                    failedQuery = addDateFilter(failedQuery, shotAttemptColumn);
                    const { count: failed, error: errF } = await failedQuery;
                    if (errF) throw new Error(`Erro ao contar disparos com falha: ${errF.message}`);
                    
                    return { attempts: attempts || 0, completed: completed || 0, failed: failed || 0, successfulLeads: (completedData || []).map(item => normalizePhoneNumber(item[leadsIdColumn])) };
                };
                
                const fetchIncomingShotsCount = async () => {
                    if (!incomingShotsTableName) return 0;
                    // Pending shots usually represents current backlog, typically not filtered by date unless specifically asked for "pending created at"
                    const { count, error } = await supabaseClient.from(incomingShotsTableName).select('*', { count: 'exact', head: true });
                    if (error) throw new Error(`Erro ao contar disparos pendentes: ${error.message}`);
                    return count || 0;
                };

                const fetchAvgResponseTime = async () => {
                    const required = [n8nExecutionsTableName, executionStartedAtColumn, executionFinishedAtColumn];
                    if (required.some(f => !f)) return 0;
                    let query = supabaseClient.from(n8nExecutionsTableName).select(`${executionStartedAtColumn}, ${executionFinishedAtColumn}`);
                    query = addDateFilter(query, executionStartedAtColumn);
                    const { data, error } = await query;
                    if (error) throw new Error(`Erro ao buscar execuções: ${error.message}`);
                    if (!data || data.length === 0) return 0;
                    const durations = data.map(ex => {
                        const start = new Date(ex[executionStartedAtColumn]).getTime();
                        const finish = new Date(ex[executionFinishedAtColumn]).getTime();
                        if (isNaN(start) || isNaN(finish) || finish <= start) return 0;
                        return (finish - start) / 1000;
                    }).filter(d => d > 0);
                    return durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0;
                };

                const fetchOffHoursScheduling = async () => {
                    const required = [offHoursKeyword, chatsTableName, jsonMessageColumn, jsonContentKey, chatsCreatedAtColumn];
                    if (required.some(f => !f)) return 0;
                    let query = supabaseClient.from(chatsTableName).select(`${chatsCreatedAtColumn}`)
                        .ilike(`${jsonMessageColumn}->>${jsonContentKey}`, `%${offHoursKeyword}%`);
                    query = addDateFilter(query, chatsCreatedAtColumn);
                    const { data, error } = await query;
                    if (error) throw new Error(`Erro ao buscar qualificações fora de hora: ${error.message}`);
                    if (!data) return 0;
                    return data.filter(item => {
                        const utcDate = new Date(item[chatsCreatedAtColumn]);
                        if (isNaN(utcDate.getTime())) return false;
                        const spFormatter = new Intl.DateTimeFormat('en-US', { timeZone: 'America/Sao_Paulo', weekday: 'short', hour: 'numeric', hour12: false });
                        const parts = spFormatter.formatToParts(utcDate);
                        const day = parts.find(p => p.type === 'weekday').value;
                        const hour = parseInt(parts.find(p => p.type === 'hour').value, 10);
                        return (day === 'Sat' || day === 'Sun') || (hour < 9 || hour >= 18);
                    }).length;
                };
            
                const [ allMessages, { data: scheduledData, error: scheduledError }, outgoingShots, pendingShots, avgResponseTime, offHoursCount ] = await Promise.all([
                    fetchAllChatMessages(), fetchScheduledData(), fetchOutgoingShotsData(), fetchIncomingShotsCount(), fetchAvgResponseTime(), fetchOffHoursScheduling()
                ]);
            
                if (scheduledError) throw new Error(`Erro ao buscar agendamentos: ${scheduledError.message}`);

                // 3. LEAD STATUS LOOKUP (CRITICAL FIX FOR DATE FILTERS)
                // We need to check the status (Qualified, Followup, etc.) of the leads involved in the ACTIVITIES above.
                // We do NOT filter this lookup by "Lead Created At", because we want to know if a lead contacted TODAY is qualified, regardless of when they were born.
                
                const activeLeadIds = new Set();
                outgoingShots.successfulLeads.forEach(id => activeLeadIds.add(id));
                allMessages.forEach(msg => activeLeadIds.add(normalizePhoneNumber(msg[chatsLeadIdColumn])));
                (scheduledData || []).forEach(item => activeLeadIds.add(normalizePhoneNumber(item[chatsLeadIdColumn])));

                // Convert Set to Array for .in() query (chunking if necessary, but assuming manageable size for dashboard)
                const uniqueActiveIds = Array.from(activeLeadIds).filter(Boolean);
                const leadStatusMap = new Map();

                if (uniqueActiveIds.length > 0) {
                    // Fetch status for leads involved in current period's activity
                    // Chunking to avoid URL length issues if > 200 items (simple implementation)
                    const chunkSize = 200;
                    for (let i = 0; i < uniqueActiveIds.length; i += chunkSize) {
                        const chunk = uniqueActiveIds.slice(i, i + chunkSize);
                        const { data: statusData, error: statusError } = await supabaseClient
                            .from(leadsTableName)
                            .select(`${leadsIdColumn}, ${qualifiedColumn}, ${followupColumn}`)
                            .in(leadsIdColumn, chunk);
                        
                        if (!statusError && statusData) {
                            statusData.forEach(l => {
                                leadStatusMap.set(normalizePhoneNumber(l[leadsIdColumn]), l);
                            });
                        }
                    }
                }

                // 4. Calculate Metrics based on leadStatusMap (Dictionary)
                
                const totalPlannedShots = (outgoingShots.attempts || 0) + (pendingShots || 0);
                
                // Qualified Leads: Leads who received a shot in this period AND are marked qualified (regardless of creation date)
                const qualifiedFromShotsNumerator = outgoingShots.successfulLeads.filter(id => {
                    const lead = leadStatusMap.get(id);
                    return lead && lead[qualifiedColumn] === true;
                }).length;

                // Shots with Reply: Shots sent in this period where the Lead exists in our DB (Map check confirms existence)
                const shotsWithReplyNumerator = outgoingShots.successfulLeads.filter(id => leadStatusMap.has(id)).length;
                
                // Second Message: Leads active in this period with >= 2 messages
                const messageCountsByLead = allMessages.reduce((acc, msg) => {
                    const leadId = normalizePhoneNumber(msg[chatsLeadIdColumn]);
                    if (leadId) acc[leadId] = (acc[leadId] || 0) + 1;
                    return acc;
                }, {});
                // For the "2nd Message" metric, we usually look at the pool of leads who received shots.
                const secondMessageNumerator = outgoingShots.successfulLeads.filter(id => (messageCountsByLead[id] || 0) >= 2).length;

                const scheduledCount = new Set((scheduledData || []).map(item => normalizePhoneNumber(item[chatsLeadIdColumn]))).size;
                
                // Recovered: Leads active in this period who are marked recovered
                // (Note: This is an approximation. Ideally we'd filter by 'recovered_at' timestamp, but we use the active pool + status flag)
                let recoveredCount = 0;
                if (followupColumn && qualifiedColumn) {
                    recoveredCount = Array.from(leadStatusMap.values()).filter(lead => lead[followupColumn] && lead[qualifiedColumn] === true).length;
                }
                
                updateUI({
                    total: totalLeads || 0, totalPlanned: totalPlannedShots, pending: pendingShots, avgResponseTime, offHoursCount,
                    qualified: { numerator: qualifiedFromShotsNumerator, denominator: outgoingShots.completed },
                    secondMessageData: { numerator: secondMessageNumerator, denominator: shotsWithReplyNumerator },
                    scheduled: { numerator: scheduledCount, denominator: shotsWithReplyNumerator },
                    recovered: { numerator: recoveredCount, denominator: shotsWithReplyNumerator },
                    shotsData: { attempts: outgoingShots.attempts, completed: outgoingShots.completed, failed: outgoingShots.failed },
                    shotsWithReplyData: { numerator: shotsWithReplyNumerator, denominator: outgoingShots.successfulLeads.length }
                });
            }

            function updateUI(metrics) {
                totalLeadsEl.textContent = metrics.total;
                maxTotalPlannedShots = Math.max(maxTotalPlannedShots, metrics.totalPlanned || 0);
                totalPlannedShotsEl.textContent = maxTotalPlannedShots;
                pendingShotsEl.textContent = metrics.pending;
                avgResponseTimeEl.textContent = metrics.avgResponseTime > 0 ? `${metrics.avgResponseTime.toFixed(1)}s` : '-';
                
                const updateCard = (el, subEl, { numerator, denominator }) => {
                    const percent = denominator > 0 ? (numerator / denominator) * 100 : 0;
                    el.textContent = `${percent.toFixed(1)}%`;
                    subEl.textContent = `(${numerator} de ${denominator})`;
                };
                
                updateCard(qualifiedLeadsEl, qualifiedLeadsSubtitleEl, metrics.qualified);
                updateCard(secondMessageEl, secondMessageSubtitleEl, metrics.secondMessageData);
                updateCard(scheduledEl, scheduledSubtitleEl, metrics.scheduled);
                updateCard(recoveredEl, recoveredSubtitleEl, metrics.recovered);
                updateCard(successfulShotsEl, successfulShotsSubtitleEl, { numerator: metrics.shotsData.completed, denominator: metrics.shotsData.attempts });
                updateCard(failedShotsEl, failedShotsSubtitleEl, { numerator: metrics.shotsData.failed, denominator: metrics.shotsData.attempts });
                updateCard(shotsWithReplyEl, shotsWithReplySubtitleEl, metrics.shotsWithReplyData);
                updateCard(offHoursScheduledEl, offHoursScheduledSubtitleEl, { numerator: metrics.offHoursCount, denominator: metrics.qualified.numerator });
            }

            function setupRealTimeSubscription(config) {
                 if (realtimeChannels.length > 0) {
                    realtimeChannels.forEach(channel => channel.unsubscribe());
                    realtimeChannels = [];
                }
                
                const tables = [config.leadsTableName, config.chatsTableName, config.shotsTableName, config.incomingShotsTableName].filter(Boolean);
                const uniqueTables = [...new Set(tables)];

                uniqueTables.forEach(tableName => {
                    const channel = supabaseClient
                        .channel(`public:${tableName}`)
                        .on('postgres_changes', { event: '*', schema: 'public', table: tableName }, (payload) => {
                            console.log(`Real-time change detected on ${tableName}:`, payload);
                            loadMetrics(getFormConfig(), dateRange);
                        })
                        .subscribe((status, err) => {
                            if (status === 'SUBSCRIBED') console.log(`Successfully subscribed to ${tableName}!`);
                            if (status === 'CHANNEL_ERROR') console.error(`Subscription error for ${tableName}:`, err);
                        });
                    realtimeChannels.push(channel);
                });
            }

            initApp();
        });
    </script>
</body>
</html>